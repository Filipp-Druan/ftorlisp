#+TITLE: Фторлисп
#+AUTHOR: Друан Филипп Сергеевич
#+LANGUAGE: ru

#+LATEX_CLASS:  article
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \hypersetup{colorlinks=true}

* Описание языка

** Базовые типы
Базовые типы:

*** Int64
Базовый числовой тип. Поддерживает сложение, вычитание, умножение, деление.

*** Str
Строковый литерал -- это указатель на Null-терменированную область. Как в Си.

** Модули
Каждый файл - это модуль. В модуле могут быть:
1) Константы
2) Определения функций

** Константы
Константы бывают числовыми и строковыми.
#+begin_src racket
  (let num 123)
  (let string "Hello")
#+end_src
Тип константы выводится.

При этом, тип можно указать явно:
#+begin_src racket
  (let [num    Int64]    123)
  (let [string Str] "Hello")
#+end_src

** Опреаторы
В языке есть математические операторы:
#+begin_src racket
  (let a 10)
  (let b 4)

  (println (+ a b)) ; 14
  (println (- a b)) ; 6
  (println (* a b)) ; 40
  (println (/ a b)) ; 2 Целочисленное деление
  (println (modulo a b)) ; 2
#+end_src

** Переменные
В языке есть переменные. Они объявляются ключвым словом let-mut, 

** Функции
Функции определяются вот так:
#+begin_src racket
  (define (foo [a Int64] [b Int64]) I64
     (+ a b))
#+end_src
Ключевое слово define, после него идёт список из имени и параметров каждый параметр - это список из имени и типа. Дальше -- тип возвращаемого значения.
Все остальные выражения - это тело функции. В ней могут быть:
1) Объя

Вызываются функции как в обычном Лиспе:
#+begin_src racket
(print num)
#+end_src

Функции могут быть перегружены по первому параметру.


* Структура компилятора
** Синтаксический анализ
Код считывается при помощи лексера и парсера.
Лексер и парсер в итоге выдают простые S-выражения. Для каждого выражения мы сохраняем позицию его начала. Если при считывании выдалась ошибка, мы выдаём узел ошибки.

Дальше идёт работа с абстрактным синтаксическим деревом. Для каждого вида стейтментов и выражений создаётся соответствующая структура. Если мы нашли какую-то ошибку, мы создаём узел ошибки.

Когда же нам нужно проверять программу на ошибки?
После синтаксического разбора и построения АСТ, мы можем либо перейти к проверке типов там, где это возможно, либо сразу выдать все ошибки, которые получились во время синтаксического дерева.

В первой версии компилятора нет проверки типов, так что можно проверять только существование функций и переменных.
